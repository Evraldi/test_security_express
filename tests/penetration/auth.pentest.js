/**
 * Authentication Penetration Tests
 * 
 * This file contains tests that simulate various attacks against
 * the authentication system to verify security measures.
 */

const request = require('supertest');
const app = require('../../for_test');

describe('Authentication Penetration Tests', () => {
  let agent;
  let csrfToken;
  
  beforeEach(async () => {
    agent = request.agent(app);
    
    // Get CSRF token
    try {
      const response = await agent.get('/api/auth/csrf-token');
      if (response.status === 200 && response.body.csrfToken) {
        csrfToken = response.body.csrfToken;
      }
    } catch (error) {
      console.error('Error getting CSRF token:', error.message);
    }
  });
  
  describe('SQL Injection Attacks', () => {
    const sqlInjectionPayloads = [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "' OR '1'='1' /*",
      "' OR 1=1 --",
      "' UNION SELECT username, password FROM users --",
      "admin'--",
      "1' OR '1' = '1'",
      "1' OR '1' = '1' -- -",
      "' OR 1 -- -",
      "' OR 'x'='x",
      "' AND id IS NULL; --",
      "' UNION ALL SELECT 1,2,3,4,5,6,name FROM users; --"
    ];
    
    test.each(sqlInjectionPayloads)('should prevent SQL injection: %s', async (payload) => {
      const response = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', csrfToken)
        .send({
          email: payload,
          password: payload
        });
      
      // Should not succeed (200) or crash (500)
      expect(response.status).not.toBe(200);
      expect(response.status).not.toBe(500);
    });
  });
  
  describe('XSS Attacks', () => {
    const xssPayloads = [
      "<script>alert('XSS')</script>",
      "<img src='x' onerror='alert(\"XSS\")'>",
      "<svg/onload=alert('XSS')>",
      "<iframe src='javascript:alert(\"XSS\")'></iframe>",
      "javascript:alert('XSS')",
      "<a href='javascript:alert(\"XSS\")'>Click me</a>",
      "<div style='background-image: url(javascript:alert(\"XSS\"))'></div>",
      "<input type='text' onfocus='alert(\"XSS\")' autofocus>",
      "<body onload='alert(\"XSS\")'>",
      "<img src='x' onmouseover='alert(\"XSS\")'>",
      "<script>document.write('<scr'+'ipt>alert(\"XSS\")</scr'+'ipt>')</script>"
    ];
    
    test.each(xssPayloads)('should sanitize XSS payload: %s', async (payload) => {
      const response = await agent
        .post('/api/auth/register')
        .set('X-CSRF-Token', csrfToken)
        .send({
          email: `xss.test.${Date.now()}@example.com`,
          password: 'SecureP@ssw0rd123',
          name: payload
        });
      
      // Check that the response doesn't contain unescaped XSS payload
      const responseText = JSON.stringify(response.body);
      expect(responseText).not.toContain(payload);
      
      // Specifically check for script tags
      if (payload.includes('<script>')) {
        expect(responseText).not.toContain('<script>');
      }
    });
  });
  
  describe('CSRF Attacks', () => {
    it('should prevent login without proper CSRF token', async () => {
      // Try to login without CSRF token
      const response1 = await agent
        .post('/api/auth/login')
        .send({
          email: 'test@example.com',
          password: 'SecureP@ssw0rd123'
        });
      
      expect(response1.status).toBe(403);
      
      // Try to login with incorrect CSRF token
      const response2 = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', 'fake-csrf-token')
        .send({
          email: 'test@example.com',
          password: 'SecureP@ssw0rd123'
        });
      
      expect(response2.status).toBe(403);
      
      // Try to login with expired CSRF token (simulate by getting a new token)
      const oldToken = csrfToken;
      
      // Get a new token, making the old one invalid
      const csrfResponse = await agent.get('/api/auth/csrf-token');
      csrfToken = csrfResponse.body.csrfToken;
      
      // Try to use the old token
      const response3 = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', oldToken)
        .send({
          email: 'test@example.com',
          password: 'SecureP@ssw0rd123'
        });
      
      expect(response3.status).toBe(403);
    });
  });
  
  describe('Brute Force Attacks', () => {
    it('should prevent brute force password guessing', async () => {
      const email = 'brute.force@example.com';
      const passwords = [
        'password1', 'password2', 'password3', 'password4', 'password5',
        'password6', 'password7', 'password8', 'password9', 'password10',
        'password11', 'password12', 'password13', 'password14', 'password15'
      ];
      
      // Try multiple passwords
      for (const password of passwords) {
        // Get a fresh CSRF token for each request
        const csrfResponse = await agent.get('/api/auth/csrf-token');
        const freshCsrfToken = csrfResponse.body.csrfToken;
        
        await agent
          .post('/api/auth/login')
          .set('X-CSRF-Token', freshCsrfToken)
          .send({ email, password });
      }
      
      // Get a fresh CSRF token
      const csrfResponse = await agent.get('/api/auth/csrf-token');
      const freshCsrfToken = csrfResponse.body.csrfToken;
      
      // Try one more login
      const response = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', freshCsrfToken)
        .send({
          email,
          password: 'final_attempt'
        });
      
      // Should be rate limited
      expect(response.status).toBe(429);
    });
  });
  
  describe('JWT Security', () => {
    it('should detect and reject tampered JWT tokens', async () => {
      // First login to get a valid token
      const loginResponse = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', csrfToken)
        .send({
          email: 'security.test@example.com',
          password: 'SecureP@ssw0rd123'
        });
      
      if (loginResponse.status === 200 && loginResponse.body.token) {
        const token = loginResponse.body.token;
        
        // Tamper with the token
        const parts = token.split('.');
        
        // Decode payload
        const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());
        
        // Modify payload (e.g., add admin role)
        payload.role = 'admin';
        
        // Re-encode payload
        const tamperedPayload = Buffer.from(JSON.stringify(payload)).toString('base64')
          .replace(/=/g, ''); // Remove padding
        
        // Create tampered token
        const tamperedToken = `${parts[0]}.${tamperedPayload}.${parts[2]}`;
        
        // Try to access a protected route with tampered token
        const response = await request(app)
          .get('/api/auth/protected') // Assuming there's a protected route
          .set('Authorization', `Bearer ${tamperedToken}`)
          .set('X-CSRF-Token', csrfToken);
        
        // Should be rejected
        expect(response.status).toBe(401);
      }
    });
    
    it('should reject expired JWT tokens', async () => {
      // Create an expired token (this is a simplified example)
      const header = {
        alg: 'HS256',
        typ: 'JWT'
      };
      
      const payload = {
        sub: '123',
        email: 'test@example.com',
        iat: Math.floor(Date.now() / 1000) - 3600, // 1 hour ago
        exp: Math.floor(Date.now() / 1000) - 1800  // Expired 30 minutes ago
      };
      
      // Encode header and payload
      const encodedHeader = Buffer.from(JSON.stringify(header)).toString('base64')
        .replace(/=/g, '');
      const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64')
        .replace(/=/g, '');
      
      // Create a fake signature (we don't have the secret key)
      const fakeSignature = 'fake_signature';
      
      // Create expired token
      const expiredToken = `${encodedHeader}.${encodedPayload}.${fakeSignature}`;
      
      // Try to access a protected route with expired token
      const response = await request(app)
        .get('/api/auth/protected') // Assuming there's a protected route
        .set('Authorization', `Bearer ${expiredToken}`)
        .set('X-CSRF-Token', csrfToken);
      
      // Should be rejected
      expect(response.status).toBe(401);
    });
  });
  
  describe('Header Injection', () => {
    it('should prevent header injection attacks', async () => {
      const response = await agent
        .post('/api/auth/login')
        .set('X-CSRF-Token', csrfToken)
        .set('X-Forwarded-Host', 'evil.com')
        .send({
          email: 'test@example.com',
          password: 'SecureP@ssw0rd123'
        });
      
      // Should not redirect to evil.com
      expect(response.headers.location).not.toContain('evil.com');
    });
  });
});
